import { LevelData } from '@/types';

/**
 * Compress level data into URL-friendly string format:
 * "width:height|anchor1:color1,anchor2:color2|path1:cell1.cell2;path2:cell1.cell2"
 */
export const compressLevel = (data: LevelData | null): string => {
  if (!data || !data.anchors) return '';
  const aStr = Object.entries(data.anchors)
    .map(([k, v]) => `${k}:${v.colorId}`)
    .join(',');
  const pStr = data.solvedPaths
    ? data.solvedPaths.map(p => `${p.colorId}:${p.path.join('.')}`).join(';')
    : '';
  return `${data.width}:${data.height}|${aStr}|${pStr}`;
};

/**
 * Decompress level data from string format.
 * Handles legacy format (single number for square grids) and new format (width:height).
 */
export const decompressLevel = (str: string | null): LevelData | null => {
  try {
    if (!str || typeof str !== 'string') return null;
    const parts = str.split('|');
    if (parts.length < 2) return null;

    let w: number, h: number;
    // Support legacy format (single number) and new format (width:height)
    if (parts[0].includes(':')) {
      const dims = parts[0].split(':');
      w = parseInt(dims[0]);
      h = parseInt(dims[1]);
    } else {
      w = parseInt(parts[0]);
      h = w;
    }

    if (isNaN(w) || isNaN(h)) return null;

    const aStr = parts[1];
    const pStr = parts[2];
    const anchors: Record<number, { colorId: number; type: 'endpoint' }> = {};

    if (aStr) {
      aStr.split(',').forEach(s => {
        const [idx, col] = s.split(':');
        if (idx && col) {
          anchors[parseInt(idx)] = { colorId: parseInt(col), type: 'endpoint' };
        }
      });
    }

    const solvedPaths: Array<{ colorId: number; path: number[] }> = [];
    if (pStr) {
      pStr.split(';').forEach(s => {
        const [col, pathStr] = s.split(':');
        if (pathStr) {
          solvedPaths.push({
            colorId: parseInt(col),
            path: pathStr.split('.').map(Number)
          });
        }
      });
    }

    return {
      width: w,
      height: h,
      anchors,
      difficulty: Math.max(Object.keys(anchors).length / 2, solvedPaths.length),
      solvedPaths
    };
  } catch (e) {
    return null;
  }
};

/**
 * Generate hash for level uniqueness checking.
 * Uses anchor positions and colors only (not paths) for faster comparison.
 */
export const generateLevelHash = (levelData: LevelData | null): string => {
  if (!levelData || !levelData.anchors) return "invalid";
  const anchorStrings = Object.entries(levelData.anchors)
    .map(([idx, data]) => `${idx}:${data.colorId}`)
    .sort((a, b) => parseInt(a.split(':')[0]) - parseInt(b.split(':')[0]));
  return `${levelData.width}x${levelData.height}:${anchorStrings.join('|')}`;
};

/**
 * Checks if a level hash has been generated before across all game modes.
 * 
 * Used to ensure global level uniqueness - a level generated in Campaign
 * will not appear in Zen Mode, Time Attack, or any other game mode.
 * 
 * @param hash - The level hash to check (generated by generateLevelHash)
 * @param generatedHashes - Array of previously generated level hashes
 * @returns True if the hash exists (level was already generated), false otherwise
 */
export const isLevelHashGenerated = (hash: string, generatedHashes: string[]): boolean => {
  return generatedHashes.includes(hash);
};

/**
 * Adds a level hash to the generated hashes array if it doesn't already exist.
 * 
 * Maintains immutability by returning a new array. Used to track all generated
 * levels across all game modes for global uniqueness.
 * 
 * @param hash - The level hash to add (generated by generateLevelHash)
 * @param generatedHashes - Array of previously generated level hashes
 * @returns Updated array of generated hashes (new array if hash was added, same array if already exists)
 */
export const addLevelHash = (hash: string, generatedHashes: string[]): string[] => {
  if (!generatedHashes.includes(hash)) {
    return [...generatedHashes, hash];
  }
  return generatedHashes;
};
